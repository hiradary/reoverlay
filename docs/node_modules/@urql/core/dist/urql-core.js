"use strict";

function _ref2(a, c, b) {
  return b.indexOf(a) === c;
}

function _ref3(a) {
  return a.kind === kinds.Kind.FIELD && "__typename" === a.name.value;
}

function withPromise(a) {
  a.toPromise = function() {
    return wonka.toPromise(wonka.take(1)(a));
  };
  return a;
}

function _ref(a) {
  return a.path || a.extensions ? {
    message: a.message,
    path: a.path,
    extensions: a.extensions
  } : a.message;
}

function _ref$1(a) {
  return fetchSource._extends({}, a, {
    query: formatDocument(a.query)
  });
}

function _ref5(a) {
  return "query" !== a.operationName || "cache-only" !== a.context.requestPolicy;
}

function _ref6(a) {
  return addMetadata(a, {
    cacheOutcome: "miss"
  });
}

function _ref8(a) {
  return shouldSkip$1(a);
}

function _ref2$1(a) {
  return console.log("[Exchange debug]: Completed operation: ", a);
}

function _ref3$1(a) {
  return console.log("[Exchange debug]: Incoming operation: ", a);
}

function _ref$2(a) {
  return "query" === a.operationName || "mutation" === a.operationName;
}

function _ref2$2(a) {
  return "query" !== a.operationName && "mutation" !== a.operationName;
}

function _ref$3() {
  return !1;
}

function _ref3$2(a) {
  a.data = maskTypename(a.data);
  return a;
}

var fetchSource = require("./838e26bf.js"), wonka = require("wonka"), parser = require("graphql/language/parser"), printer = require("graphql/language/printer"), kinds = require("graphql/language/kinds"), visitor = require("graphql/language/visitor"), phash = function(a, c) {
  a |= 0;
  for (var b = 0, d = 0 | c.length; b < d; b++) {
    a = (a << 5) + a + c.charCodeAt(b);
  }
  return a;
}, hash = function(a) {
  return phash(5381, a) >>> 0;
}, hashQuery = function(a) {
  return hash(a.replace(/[\s,]+/g, " ").trim());
}, docs = Object.create(null), keyProp = "__key", createRequest = function(a, c) {
  if ("string" == typeof a) {
    var b = hashQuery(a);
    a = void 0 !== docs[b] ? docs[b] : parser.parse(a);
  } else {
    void 0 !== a[keyProp] ? b = a[keyProp] : (b = hashQuery(printer.print(a)), a = void 0 !== docs[b] ? docs[b] : a);
  }
  docs[b] = a;
  a[keyProp] = b;
  return {
    key: c ? phash(b, fetchSource.stringifyVariables(c)) >>> 0 : b,
    query: a,
    variables: c || {}
  };
}, addMetadata = function(a, c) {
  return fetchSource._extends({}, a, {
    context: fetchSource._extends({}, a.context, {
      meta: fetchSource._extends({}, a.context.meta, c)
    })
  });
}, collectTypes = function(a, c) {
  void 0 === c && (c = []);
  if (Array.isArray(a)) {
    a.forEach((function b(a) {
      collectTypes(a, c);
    }));
  } else if ("object" == typeof a && null !== a) {
    for (var d in a) {
      "__typename" === d && "string" == typeof a[d] ? c.push(a[d]) : collectTypes(a[d], c);
    }
  }
  return c;
}, collectTypesFromResponse = function(a) {
  return collectTypes(a).filter(_ref2);
}, formatNode = function(a) {
  if (a.selectionSet && !a.selectionSet.selections.some(_ref3)) {
    return a.selectionSet.selections.push({
      kind: kinds.Kind.FIELD,
      name: {
        kind: kinds.Kind.NAME,
        value: "__typename"
      }
    }), a;
  }
}, formatDocument = function(a) {
  return visitor.visit(a, {
    Field: formatNode,
    InlineFragment: formatNode
  });
}, toSuspenseSource = function(a) {
  return function(c) {
    var b = wonka.share(a), d = !1, f = !1;
    wonka.onPush((function() {
      return d = !0;
    }))(wonka.takeWhile((function() {
      return !f;
    }))(b))(c);
    if (!d) {
      throw f = !0, c(0), wonka.toPromise(wonka.take(1)(b));
    }
  };
}, maskTypename = function(a) {
  return a && "object" == typeof a ? Object.keys(a).reduce((function(c, b) {
    var d = a[b];
    "__typename" === b ? Object.defineProperty(c, "__typename", {
      enumerable: !1,
      value: d
    }) : Array.isArray(d) ? c[b] = d.map(maskTypename) : c[b] = d && "object" == typeof d && "__typename" in d ? maskTypename(d) : d;
    return c;
  }), {}) : a;
}, noop = function() {}, shouldSkip = function(a) {
  return "subscription" !== (a = a.operationName) && "query" !== a;
}, serializeResult = function(a) {
  var c = a.error;
  a = {
    data: a.data,
    error: void 0
  };
  c && (a.error = {
    graphQLErrors: c.graphQLErrors.map(_ref),
    networkError: c.networkError ? "" + c.networkError : void 0
  });
  return a;
}, deserializeResult = function(a, c) {
  var b = c.error;
  return {
    operation: a,
    data: c.data,
    extensions: void 0,
    error: b ? new fetchSource.CombinedError({
      networkError: b.networkError ? Error(b.networkError) : void 0,
      graphQLErrors: b.graphQLErrors && b.graphQLErrors.length ? b.graphQLErrors : void 0
    }) : void 0
  };
}, ssrExchange = function(a) {
  function c(a) {
    return !h(a);
  }
  function b(a) {
    return deserializeResult(a, k[a.key]);
  }
  function d(a) {
    return h(a);
  }
  function f(a) {
    var b = a.operation;
    shouldSkip(b) || (a = serializeResult(a), k[b.key] = a);
  }
  function g(a) {
    delete k[a.operation.key];
  }
  var k = {}, h = function(a) {
    return !shouldSkip(a) && void 0 !== k[a.key];
  }, e = function(e) {
    var k = e.client, l = e.forward;
    return function(e) {
      var q = a && "boolean" == typeof a.isClient ? !!a.isClient : !k.suspense, h = wonka.share(e);
      e = l(wonka.filter(c)(h));
      h = wonka.map(b)(wonka.filter(d)(h));
      q ? h = wonka.tap(g)(h) : e = wonka.tap(f)(e);
      return wonka.merge([ e, h ]);
    };
  };
  e.restoreData = function(a) {
    return fetchSource._extends(k, a);
  };
  e.extractData = function() {
    return fetchSource._extends({}, k);
  };
  a && a.initialState && e.restoreData(a.initialState);
  return e;
}, shouldSkip$1 = function(a) {
  return "mutation" !== (a = a.operationName) && "query" !== a;
}, cacheExchange = function(a) {
  function c(a) {
    var b = e.get(a.key);
    "production" !== process.env.NODE_ENV && h(fetchSource._extends({}, {
      operation: a
    }, b ? {
      type: "cacheHit",
      message: "The result was successfully retried from the cache"
    } : {
      type: "cacheMiss",
      message: "The result could not be retrieved from the cache"
    }));
    b = fetchSource._extends({}, b, {
      operation: addMetadata(a, {
        cacheOutcome: b ? "hit" : "miss"
      })
    });
    "cache-and-network" === a.context.requestPolicy && (b.stale = !0, reexecuteOperation(k, a));
    return b;
  }
  function b(a) {
    return !shouldSkip$1(a) && n(a);
  }
  function d(a) {
    a.operation && "mutation" === a.operation.operationName ? m(a) : a.operation && "query" === a.operation.operationName && p(a);
  }
  function f(a) {
    return !shouldSkip$1(a) && !n(a);
  }
  var l, m, p, n, g = a.forward, k = a.client, h = a.dispatchDebug, e = new Map;
  a = Object.create(null);
  l = _ref$1, m = afterMutation(e, a, k, h), p = afterQuery(e, a), n = function(a) {
    var c = a.context.requestPolicy;
    return "query" === a.operationName && "network-only" !== c && ("cache-only" === c || e.has(a.key));
  };
  return function(a) {
    var e = wonka.share(a);
    a = wonka.map(c)(wonka.filter(b)(e));
    e = wonka.tap(d)(g(wonka.filter(_ref5)(wonka.map(_ref6)(wonka.merge([ wonka.map(l)(wonka.filter(f)(e)), wonka.filter(_ref8)(e) ])))));
    return wonka.merge([ a, e ]);
  };
}, reexecuteOperation = function(a, c) {
  return a.reexecuteOperation(fetchSource._extends({}, c, {
    context: fetchSource._extends({}, c.context, {
      requestPolicy: "network-only"
    })
  }));
}, afterMutation = function(a, c, b, d) {
  function f(c) {
    if (a.has(c)) {
      var d = a.get(c).operation;
      a.delete(c);
      reexecuteOperation(b, d);
    }
  }
  return function(a) {
    function b(a) {
      h.add(a);
    }
    var h = new Set, e = a.operation.context.additionalTypenames;
    e = collectTypesFromResponse(a.data).concat(e || []);
    "production" !== process.env.NODE_ENV && d({
      type: "cacheInvalidation",
      message: "The following typenames have been invalidated: " + e,
      operation: a.operation,
      data: {
        typenames: e,
        response: a
      },
      source: "cacheExchange"
    });
    e.forEach((function(a) {
      (a = c[a] || (c[a] = new Set)).forEach(b);
      a.clear();
    }));
    h.forEach(f);
  };
}, afterQuery = function(a, c) {
  return function(b) {
    var d = b.operation, f = b.data, g = d.context.additionalTypenames;
    null != f && (a.set(d.key, {
      operation: d,
      data: f,
      error: b.error
    }), collectTypesFromResponse(b.data).concat(g || []).forEach((function(a) {
      (c[a] || (c[a] = new Set)).add(d.key);
    })));
  };
}, subscriptionExchange = function(a) {
  function c(a) {
    return "subscription" === (a = a.operationName) || !!d && ("query" === a || "mutation" === a);
  }
  var b = a.forwardSubscription, d = a.enableAllOperations;
  return function(a) {
    function d(a) {
      return !l(a);
    }
    var k = a.client, f = a.forward, e = function(a) {
      var c = b({
        key: a.key.toString(36),
        query: printer.print(a.query),
        variables: a.variables,
        context: fetchSource._extends({}, a.context)
      });
      return wonka.make((function(b) {
        function e(b) {
          return h(fetchSource.makeResult(a, b));
        }
        function d(b) {
          return h(fetchSource.makeErrorResult(a, b));
        }
        function f() {
          l || (l = !0, "subscription" === a.operationName && k.reexecuteOperation(fetchSource._extends({}, a, {
            operationName: "teardown"
          })), g());
        }
        var m, h = b.next, g = b.complete, l = !1;
        Promise.resolve().then((function() {
          l || (m = c.subscribe({
            next: e,
            error: d,
            complete: f
          }));
        }));
        return function() {
          l = !0;
          m && m.unsubscribe();
        };
      }));
    }, l = c;
    return function(a) {
      var c, b = wonka.share(a);
      a = wonka.mergeMap((function(a) {
        var c = a.key, d = wonka.filter((function(a) {
          return "teardown" === a.operationName && a.key === c;
        }))(b);
        return wonka.takeUntil(d)(e(a));
      }))(wonka.filter(l)(b));
      c = f(wonka.filter(d)(b));
      return wonka.merge([ a, c ]);
    };
  };
}, debugExchange = function(a) {
  var d = a.forward;
  return "production" === process.env.NODE_ENV ? function c(a) {
    return d(a);
  } : function b(a) {
    return wonka.tap(_ref2$1)(d(wonka.tap(_ref3$1)(a)));
  };
}, dedupExchange = function(a) {
  var c = a.forward, b = a.dispatchDebug, d = new Set, f = function(a) {
    var c = a.key, e = a.operationName;
    if ("teardown" === e) {
      return d.delete(c), !0;
    }
    if ("query" !== e && "subscription" !== e) {
      return !0;
    }
    e = d.has(c);
    d.add(c);
    e && "production" !== process.env.NODE_ENV && b({
      type: "dedup",
      message: "An operation has been deduped.",
      operation: a,
      source: "dedupExchange"
    });
    return !e;
  }, g = function(a) {
    d.delete(a.operation.key);
  };
  return function(a) {
    a = wonka.filter(f)(a);
    return wonka.tap(g)(c(a));
  };
}, fetchExchange = function(a) {
  var c = a.forward, b = a.dispatchDebug;
  return function(a) {
    var g, d = wonka.share(a);
    a = wonka.mergeMap((function(a) {
      var c = a.key, e = wonka.filter((function(a) {
        return "teardown" === a.operationName && a.key === c;
      }))(d), f = fetchSource.makeFetchBody(a), g = fetchSource.makeFetchURL(a, f), k = fetchSource.makeFetchOptions(a, f);
      "production" !== process.env.NODE_ENV && b({
        type: "fetchRequest",
        message: "A fetch request is being executed.",
        operation: a,
        data: {
          url: g,
          fetchOptions: k
        },
        source: "fetchExchange"
      });
      return wonka.onPush((function(c) {
        var e = c.data ? void 0 : c.error;
        "production" !== process.env.NODE_ENV && b({
          type: e ? "fetchError" : "fetchSuccess",
          message: "A " + (e ? "failed" : "successful") + " fetch response has been returned.",
          operation: a,
          data: {
            url: g,
            fetchOptions: k,
            value: e || c
          },
          source: "fetchExchange"
        });
      }))(wonka.takeUntil(e)(fetchSource.makeFetchSource(a, g, k)));
    }))(wonka.filter(_ref$2)(d));
    g = c(wonka.filter(_ref2$2)(d));
    return wonka.merge([ a, g ]);
  };
}, fallbackExchange = function(a) {
  function c(a) {
    if ("teardown" !== a.operationName && "production" !== process.env.NODE_ENV) {
      var c = 'No exchange has handled operations of type "' + a.operationName + "\". Check whether you've added an exchange responsible for these operations.";
      "production" !== process.env.NODE_ENV && b({
        type: "fallbackCatch",
        message: c,
        operation: a,
        source: "fallbackExchange"
      });
      console.warn(c);
    }
  }
  var b = a.dispatchDebug;
  return function(a) {
    return wonka.filter(_ref$3)(wonka.tap(c)(a));
  };
}, fallbackExchangeIO = fallbackExchange({
  dispatchDebug: noop
}), composeExchanges = function(a) {
  return function(c) {
    var b = c.client, d = c.dispatchDebug;
    return a.reduceRight((function(a, c) {
      return c({
        client: b,
        forward: a,
        dispatchDebug: function(a) {
          "production" !== process.env.NODE_ENV && d(fetchSource._extends({}, {
            timestamp: Date.now(),
            source: c.name
          }, a));
        }
      });
    }), c.forward);
  };
}, defaultExchanges = [ dedupExchange, cacheExchange, fetchExchange ], createClient = function(a) {
  return new Client(a);
}, Client = function(a) {
  var d, f, g, k, h, b = this;
  this.activeOperations = Object.create(null);
  this.queue = [];
  this.createOperationContext = function(a) {
    return fetchSource._extends({}, {
      url: b.url,
      fetchOptions: b.fetchOptions,
      fetch: b.fetch,
      preferGetMethod: b.preferGetMethod
    }, a, {
      requestPolicy: (a || {}).requestPolicy || b.requestPolicy
    });
  };
  this.createRequestOperation = function(a, c, d) {
    return {
      key: c.key,
      query: c.query,
      variables: c.variables,
      operationName: a,
      context: b.createOperationContext(d)
    };
  };
  this.executeQuery = function(a, c) {
    a = b.createRequestOperation("query", a, c);
    var e = b.executeRequestOperation(a);
    return (a = a.context.pollInterval) ? wonka.switchMap((function d() {
      return e;
    }))(wonka.merge([ wonka.fromValue(0), wonka.interval(a) ])) : e;
  };
  this.executeSubscription = function(a, c) {
    a = b.createRequestOperation("subscription", a, c);
    return b.executeRequestOperation(a);
  };
  this.executeMutation = function(a, c) {
    a = b.createRequestOperation("mutation", a, c);
    return b.executeRequestOperation(a);
  };
  if ("production" !== process.env.NODE_ENV && !a.url) {
    throw Error("You are creating an urql-client without a url.");
  }
  d = noop;
  if ("production" !== process.env.NODE_ENV) {
    f = (d = wonka.makeSubject()).next, g = d.source;
    this.subscribeToDebugTarget = function c(a) {
      return wonka.subscribe(a)(g);
    };
    d = f;
  }
  this.url = a.url;
  this.fetchOptions = a.fetchOptions;
  this.fetch = a.fetch;
  this.suspense = !!a.suspense;
  this.requestPolicy = a.requestPolicy || "cache-first";
  this.preferGetMethod = !!a.preferGetMethod;
  this.maskTypename = !!a.maskTypename;
  f = wonka.makeSubject();
  k = f.next;
  this.operations$ = f.source;
  h = !1;
  this.dispatchOperation = function(a) {
    h = !0;
    for (a && k(a); a = b.queue.shift(); ) {
      k(a);
    }
    h = !1;
  };
  this.reexecuteOperation = function(a) {
    0 < (b.activeOperations[a.key] || 0) && (b.queue.push(a), h || Promise.resolve().then(b.dispatchOperation));
  };
  a = composeExchanges(void 0 !== a.exchanges ? a.exchanges : defaultExchanges);
  this.results$ = wonka.share(a({
    client: this,
    dispatchDebug: d,
    forward: fallbackExchange({
      dispatchDebug: d
    })
  })(this.operations$));
  wonka.publish(this.results$);
};

Client.prototype.onOperationStart = function(a) {
  var c = a.key;
  this.activeOperations[c] = (this.activeOperations[c] || 0) + 1;
  this.dispatchOperation(a);
};

Client.prototype.onOperationEnd = function(a) {
  var c = a.key, b = this.activeOperations[c] || 0;
  0 >= (this.activeOperations[c] = 0 >= b ? 0 : b - 1) && this.dispatchOperation(fetchSource._extends({}, a, {
    operationName: "teardown"
  }));
};

Client.prototype.executeRequestOperation = function(a) {
  var k, b = this, d = a.key, f = a.operationName, g = wonka.filter((function(a) {
    return a.operation.key === d;
  }))(this.results$);
  this.maskTypename && (g = wonka.map(_ref3$2)(g));
  if ("mutation" === f) {
    return wonka.take(1)(wonka.onStart((function c() {
      return b.dispatchOperation(a);
    }))(g));
  }
  k = wonka.filter((function(a) {
    return "teardown" === a.operationName && a.key === d;
  }))(this.operations$);
  g = wonka.onEnd((function() {
    b.onOperationEnd(a);
  }))(wonka.onStart((function() {
    b.onOperationStart(a);
  }))(wonka.takeUntil(k)(g)));
  return !1 !== a.context.suspense && this.suspense && "query" === f ? toSuspenseSource(g) : g;
};

Client.prototype.query = function(a, c, b) {
  b && "boolean" == typeof b.suspense || (b = fetchSource._extends({}, b, {
    suspense: !1
  }));
  return withPromise(this.executeQuery(createRequest(a, c), b));
};

Client.prototype.readQuery = function(a, c, b) {
  var d = null;
  wonka.subscribe((function(a) {
    d = a;
  }))(this.executeQuery(createRequest(a, c), b)).unsubscribe();
  return d;
};

Client.prototype.subscription = function(a, c, b) {
  return this.executeSubscription(createRequest(a, c), b);
};

Client.prototype.mutation = function(a, c, b) {
  return withPromise(this.executeMutation(createRequest(a, c), b));
};

exports.CombinedError = fetchSource.CombinedError;

exports.makeErrorResult = fetchSource.makeErrorResult;

exports.makeResult = fetchSource.makeResult;

exports.stringifyVariables = fetchSource.stringifyVariables;

exports.Client = Client;

exports.cacheExchange = cacheExchange;

exports.composeExchanges = composeExchanges;

exports.createClient = createClient;

exports.createRequest = createRequest;

exports.debugExchange = debugExchange;

exports.dedupExchange = dedupExchange;

exports.defaultExchanges = defaultExchanges;

exports.fallbackExchangeIO = fallbackExchangeIO;

exports.fetchExchange = fetchExchange;

exports.formatDocument = formatDocument;

exports.maskTypename = maskTypename;

exports.ssrExchange = ssrExchange;

exports.subscriptionExchange = subscriptionExchange;
//# sourceMappingURL=urql-core.js.map
