{"version":3,"file":"index.esm.js","sources":["../../../dist/mock/src/mocking.js"],"sourcesContent":["import { graphql, getNullableType, getNamedType, isSchema, isObjectType, isInterfaceType, isListType, isEnumType, isAbstractType, GraphQLInterfaceType, GraphQLUnionType, } from 'graphql';\nimport { buildSchemaFromTypeDefinitions } from '@graphql-tools/schema';\nimport { mapSchema, MapperKind } from '@graphql-tools/utils';\n/**\n * This function wraps addMocksToSchema for more convenience\n */\nexport function mockServer(schema, mocks, preserveResolvers = false) {\n    let mySchema;\n    if (!isSchema(schema)) {\n        // TODO: provide useful error messages here if this fails\n        mySchema = buildSchemaFromTypeDefinitions(schema);\n    }\n    else {\n        mySchema = schema;\n    }\n    mySchema = addMocksToSchema({ schema: mySchema, mocks, preserveResolvers });\n    return { query: (query, vars) => graphql(mySchema, query, {}, {}, vars) };\n}\nfunction uuidv4() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (Math.random() * 16) | 0;\n        // eslint-disable-next-line eqeqeq\n        const v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nconst defaultMockMap = new Map();\ndefaultMockMap.set('Int', () => Math.round(Math.random() * 200) - 100);\ndefaultMockMap.set('Float', () => Math.random() * 200 - 100);\ndefaultMockMap.set('String', () => 'Hello World');\ndefaultMockMap.set('Boolean', () => Math.random() > 0.5);\ndefaultMockMap.set('ID', () => uuidv4());\n// TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\nexport function addMocksToSchema({ schema, mocks = {}, preserveResolvers = false }) {\n    if (!schema) {\n        throw new Error('Must provide schema to mock');\n    }\n    if (!isSchema(schema)) {\n        throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n    }\n    if (!isObject(mocks)) {\n        throw new Error('mocks must be of type Object');\n    }\n    // use Map internally, because that API is nicer.\n    const mockFunctionMap = new Map();\n    Object.keys(mocks).forEach(typeName => {\n        mockFunctionMap.set(typeName, mocks[typeName]);\n    });\n    mockFunctionMap.forEach((mockFunction, mockTypeName) => {\n        if (typeof mockFunction !== 'function') {\n            throw new Error(`mockFunctionMap[${mockTypeName}] must be a function`);\n        }\n    });\n    const mockType = function (type, _typeName, fieldName) {\n        // order of precendence for mocking:\n        // 1. if the object passed in already has fieldName, just use that\n        // --> if it's a function, that becomes your resolver\n        // --> if it's a value, the mock resolver will return that\n        // 2. if the nullableType is a list, recurse\n        // 2. if there's a mock defined for this typeName, that will be used\n        // 3. if there's no mock defined, use the default mocks for this type\n        return (root, args, context, info) => {\n            // nullability doesn't matter for the purpose of mocking.\n            const fieldType = getNullableType(type);\n            const namedFieldType = getNamedType(fieldType);\n            if (fieldName && root && typeof root[fieldName] !== 'undefined') {\n                let result;\n                // if we're here, the field is already defined\n                if (typeof root[fieldName] === 'function') {\n                    result = root[fieldName](root, args, context, info);\n                    if (isMockList(result)) {\n                        result = result.mock(root, args, context, info, fieldType, mockType);\n                    }\n                }\n                else {\n                    result = root[fieldName];\n                }\n                // Now we merge the result with the default mock for this type.\n                // This allows overriding defaults while writing very little code.\n                if (mockFunctionMap.has(namedFieldType.name)) {\n                    const mock = mockFunctionMap.get(namedFieldType.name);\n                    result = mergeMocks(mock.bind(null, root, args, context, info), result);\n                }\n                return result;\n            }\n            if (isListType(fieldType)) {\n                return [\n                    mockType(fieldType.ofType)(root, args, context, info),\n                    mockType(fieldType.ofType)(root, args, context, info),\n                ];\n            }\n            if (mockFunctionMap.has(fieldType.name) && !isAbstractType(fieldType)) {\n                // the object passed doesn't have this field, so we apply the default mock\n                const mock = mockFunctionMap.get(fieldType.name);\n                return mock(root, args, context, info);\n            }\n            if (isObjectType(fieldType)) {\n                // objects don't return actual data, we only need to mock scalars!\n                return {};\n            }\n            // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n            // otherwise randomly pick a type from all implementation types\n            if (isAbstractType(fieldType)) {\n                let implementationType;\n                let interfaceMockObj = {};\n                if (mockFunctionMap.has(fieldType.name)) {\n                    const mock = mockFunctionMap.get(fieldType.name);\n                    interfaceMockObj = mock(root, args, context, info);\n                    if (!interfaceMockObj || !interfaceMockObj.__typename) {\n                        return Error(`Please return a __typename in \"${fieldType.name}\"`);\n                    }\n                    implementationType = schema.getType(interfaceMockObj.__typename);\n                }\n                else {\n                    const possibleTypes = schema.getPossibleTypes(fieldType);\n                    implementationType = getRandomElement(possibleTypes);\n                }\n                return {\n                    __typename: implementationType,\n                    ...interfaceMockObj,\n                    ...mockType(implementationType)(root, args, context, info),\n                };\n            }\n            if (isEnumType(fieldType)) {\n                return getRandomElement(fieldType.getValues()).value;\n            }\n            if (defaultMockMap.has(fieldType.name)) {\n                const defaultMock = defaultMockMap.get(fieldType.name);\n                return defaultMock(root, args, context, info);\n            }\n            // if we get to here, we don't have a value, and we don't have a mock for this type,\n            // we could return undefined, but that would be hard to debug, so we throw instead.\n            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n            return Error(`No mock defined for type \"${fieldType.name}\"`);\n        };\n    };\n    return mapSchema(schema, {\n        [MapperKind.ABSTRACT_TYPE]: type => {\n            const oldResolveType = type.resolveType;\n            if (preserveResolvers && oldResolveType != null && oldResolveType.length) {\n                return;\n            }\n            // the default `resolveType` always returns null. We add a fallback\n            // resolution that works with how unions and interface are mocked\n            const resolveType = (data, _context, info) => info.schema.getType(data.__typename);\n            if (isInterfaceType(type)) {\n                return new GraphQLInterfaceType({\n                    ...type.toConfig(),\n                    resolveType,\n                });\n            }\n            else {\n                return new GraphQLUnionType({\n                    ...type.toConfig(),\n                    resolveType,\n                });\n            }\n        },\n        [MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName) => {\n            const fieldType = fieldConfig.type;\n            const fieldResolver = fieldConfig.resolve;\n            const newFieldConfig = {\n                ...fieldConfig,\n            };\n            let mockResolver = mockType(fieldType, typeName, fieldName);\n            // we have to handle the root mutation and root query types differently,\n            // because no resolver is called at the root.\n            const queryType = schema.getQueryType();\n            const isOnQueryType = queryType != null && queryType.name === typeName;\n            const mutationType = schema.getMutationType();\n            const isOnMutationType = mutationType != null && mutationType.name === typeName;\n            if (isOnQueryType || isOnMutationType) {\n                if (mockFunctionMap.has(typeName)) {\n                    const rootMock = mockFunctionMap.get(typeName);\n                    // XXX: BUG in here, need to provide proper signature for rootMock.\n                    if (typeof rootMock(undefined, {}, {}, {})[fieldName] === 'function') {\n                        mockResolver = (root, args, context, info) => {\n                            const updatedRoot = root !== null && root !== void 0 ? root : {}; // TODO: should we clone instead?\n                            updatedRoot[fieldName] = rootMock(root, args, context, info)[fieldName];\n                            // XXX this is a bit of a hack to still use mockType, which\n                            // lets you mock lists etc. as well\n                            // otherwise we could just set field.resolve to rootMock()[fieldName]\n                            // it's like pretending there was a resolver that ran before\n                            // the root resolver.\n                            return mockType(fieldConfig.type, typeName, fieldName)(updatedRoot, args, context, info);\n                        };\n                    }\n                }\n            }\n            if (!preserveResolvers || !fieldResolver) {\n                newFieldConfig.resolve = mockResolver;\n            }\n            else {\n                const oldResolver = fieldResolver;\n                newFieldConfig.resolve = (rootObject, args, context, info) => Promise.all([\n                    mockResolver(rootObject, args, context, info),\n                    oldResolver(rootObject, args, context, info),\n                ]).then(values => {\n                    const [mockedValue, resolvedValue] = values;\n                    // In case we couldn't mock\n                    if (mockedValue instanceof Error) {\n                        // only if value was not resolved, populate the error.\n                        if (undefined === resolvedValue) {\n                            throw mockedValue;\n                        }\n                        return resolvedValue;\n                    }\n                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n                        return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                    }\n                    if (isObject(mockedValue) && isObject(resolvedValue)) {\n                        // Object.assign() won't do here, as we need to all properties, including\n                        // the non-enumerable ones and defined using Object.defineProperty\n                        const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n                    }\n                    return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                });\n            }\n            return newFieldConfig;\n        },\n    });\n}\nfunction isObject(thing) {\n    return thing === Object(thing) && !Array.isArray(thing);\n}\n// returns a random element from that ary\nfunction getRandomElement(ary) {\n    const sample = Math.floor(Math.random() * ary.length);\n    return ary[sample];\n}\nfunction mergeObjects(a, b) {\n    return Object.assign(a, b);\n}\nfunction copyOwnPropsIfNotPresent(target, source) {\n    Object.getOwnPropertyNames(source).forEach(prop => {\n        if (!Object.getOwnPropertyDescriptor(target, prop)) {\n            const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n            Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);\n        }\n    });\n}\nfunction copyOwnProps(target, ...sources) {\n    sources.forEach(source => {\n        let chain = source;\n        while (chain != null) {\n            copyOwnPropsIfNotPresent(target, chain);\n            chain = Object.getPrototypeOf(chain);\n        }\n    });\n    return target;\n}\n// takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\nfunction mergeMocks(genericMockFunction, customMock) {\n    if (Array.isArray(customMock)) {\n        return customMock.map((el) => mergeMocks(genericMockFunction, el));\n    }\n    if (isObject(customMock)) {\n        return mergeObjects(genericMockFunction(), customMock);\n    }\n    return customMock;\n}\nexport function isMockList(obj) {\n    if (typeof (obj === null || obj === void 0 ? void 0 : obj.len) === 'number' || (Array.isArray(obj === null || obj === void 0 ? void 0 : obj.len) && typeof (obj === null || obj === void 0 ? void 0 : obj.len[0]) === 'number')) {\n        if (typeof obj.wrappedFunction === 'undefined' || typeof obj.wrappedFunction === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\nexport class MockList {\n    // wrappedFunction can return another MockList or a value\n    constructor(len, wrappedFunction) {\n        this.len = len;\n        if (typeof wrappedFunction !== 'undefined') {\n            if (typeof wrappedFunction !== 'function') {\n                throw new Error('Second argument to MockList must be a function or undefined');\n            }\n            this.wrappedFunction = wrappedFunction;\n        }\n    }\n    mock(root, args, context, info, fieldType, mockTypeFunc) {\n        let arr;\n        if (Array.isArray(this.len)) {\n            arr = new Array(this.randint(this.len[0], this.len[1]));\n        }\n        else {\n            arr = new Array(this.len);\n        }\n        for (let i = 0; i < arr.length; i++) {\n            if (typeof this.wrappedFunction === 'function') {\n                const res = this.wrappedFunction(root, args, context, info);\n                if (isMockList(res)) {\n                    const nullableType = getNullableType(fieldType.ofType);\n                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);\n                }\n                else {\n                    arr[i] = res;\n                }\n            }\n            else {\n                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n            }\n        }\n        return arr;\n    }\n    randint(low, high) {\n        return Math.floor(Math.random() * (high - low + 1) + low);\n    }\n}\n//# sourceMappingURL=mocking.js.map"],"names":[],"mappings":"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"}