{"version":3,"sources":["../../../src/schema/types/date.js"],"names":["moment","require","GraphQLScalarType","Kind","oneLine","ISO_8601_FORMAT","GraphQLDate","name","description","serialize","String","parseValue","parseLiteral","ast","kind","STRING","value","undefined","momentFormattingTokens","momentFormattingRegexes","YYYY","MM","DD","DDDD","HH","mm","ss","SSS","SSSSSS","E","W","WW","Z","ISO_8601_FORMAT_AS_REGEX","map","format","match","token","join","ISO_8601_FORMAT_LENGTHS","Set","reduce","acc","val","endsWith","concat","length","quickDateValidateRegex","RegExp","looksLikeDateStartRegex","looksLikeDateEndRegex","looksLikeADate","includes","test","isDate","momentDate","utc","isValid","formatDate","date","fromNow","difference","formatString","locale","normalizedDate","JSON","parse","stringify","diff","getDateResolver","options","fieldConfig","args","type","defaultValue","resolve","source","context","info","resolver","defaultFieldResolver","from","fromNode","Array","isArray","d","module","exports"],"mappings":";;AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAE,QAAF,CAAtB;;AACA,MAAM;AAAEC,EAAAA,iBAAF;AAAqBC,EAAAA;AAArB,IAA8BF,OAAO,CAAE,SAAF,CAA3C;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAcH,OAAO,CAAE,aAAF,CAA3B;;AAEA,MAAMI,eAAe,GAAG,CACrB,MADqB,EAErB,SAFqB,EAGrB,YAHqB,EAIrB,UAJqB,EAMtB;AACC,eAPqB,EAQrB,kBARqB,EASrB,iBATqB,EAUrB,qBAVqB,EAWrB,mBAXqB,EAYrB,yBAZqB,EAarB,uBAbqB,EAcrB,4BAdqB,EAerB,0BAfqB,EAgBtB;AACA;AAEA;AACC,eApBqB,EAqBrB,kBArBqB,EAsBrB,iBAtBqB,EAuBrB,qBAvBqB,EAwBrB,mBAxBqB,EAyBrB,yBAzBqB,EA0BrB,uBA1BqB,EA2BrB,4BA3BqB,EA4BrB,0BA5BqB,EA6BtB;AACA;AAEA;AACC,gBAjCqB,EAkCrB,mBAlCqB,EAmCrB,kBAnCqB,EAoCrB,sBApCqB,EAqCrB,oBArCqB,EAsCrB,0BAtCqB,EAuCrB,wBAvCqB,EAwCrB,6BAxCqB,EAyCrB,2BAzCqB,EA0CtB;AACA;AAEA;AACC,gBA9CqB,EA+CrB,mBA/CqB,EAgDrB,kBAhDqB,EAiDrB,sBAjDqB,EAkDrB,oBAlDqB,EAmDrB,0BAnDqB,EAoDrB,wBApDqB,EAqDrB,6BArDqB,EAsDrB,2BAtDqB,EAuDtB;AACA;AAEA;AACC,iBA3DqB,EA4DrB,oBA5DqB,EA6DrB,mBA7DqB,EA8DrB,uBA9DqB,EA+DrB,qBA/DqB,EAgErB,2BAhEqB,EAiErB,yBAjEqB,EAkErB,8BAlEqB,EAmErB,4BAnEqB,EAqErB,YArEqB,EAsErB,WAtEqB,EAuErB,cAvEqB,EAwErB,YAxEqB,EAyErB,WAzEqB,EA0ErB,UA1EqB,CAAxB;AA6EA,MAAMC,WAAW,GAAG,IAAIJ,iBAAJ,CAAsB;AACxCK,EAAAA,IAAI,EAAG,MADiC;AAExCC,EAAAA,WAAW,EAAEJ,OAAQ;;wEAFmB;AAKxCK,EAAAA,SAAS,EAAEC,MAL6B;AAMxCC,EAAAA,UAAU,EAAED,MAN4B;;AAOxCE,EAAAA,YAAY,CAACC,GAAD,EAAM;AAChB,WAAOA,GAAG,CAACC,IAAJ,KAAaX,IAAI,CAACY,MAAlB,GAA2BF,GAAG,CAACG,KAA/B,GAAuCC,SAA9C;AACD;;AATuC,CAAtB,CAApB;AAYA,MAAMC,sBAAsB,GAAG,qLAA/B;AACA,MAAMC,uBAAuB,GAAG;AAC9BC,EAAAA,IAAI,EAAG,QADuB;AAE9BC,EAAAA,EAAE,EAAG,QAFyB;AAG9BC,EAAAA,EAAE,EAAG,QAHyB;AAI9BC,EAAAA,IAAI,EAAG,QAJuB;AAK9BC,EAAAA,EAAE,EAAG,QALyB;AAM9BC,EAAAA,EAAE,EAAG,QANyB;AAO9BC,EAAAA,EAAE,EAAG,QAPyB;AAQ9BC,EAAAA,GAAG,EAAG,QARwB;AAS9BC,EAAAA,MAAM,EAAG,QATqB;AAU9BC,EAAAA,CAAC,EAAG,KAV0B;AAW9BC,EAAAA,CAAC,EAAG,KAX0B;AAY9BC,EAAAA,EAAE,EAAG,QAZyB;AAa9B,SAAQ,GAbsB;AAc9B,OAAM,KAdwB;AAe9BC,EAAAA,CAAC,EAAG;AAf0B,CAAhC;AAiBA,MAAMC,wBAAwB,GAAG5B,eAAe,CAAC6B,GAAhB,CAAoBC,MAAM,IACzD;AACA,CAAC,GAAGA,MAAM,CAACC,KAAP,CAAalB,sBAAb,CAAJ,EACGgB,GADH,CACOG,KAAK,IACR;AACAlB,uBAAuB,CAACkB,KAAD,CAAvB,GAAiClB,uBAAuB,CAACkB,KAAD,CAAxD,GAAkEA,KAHtE,EAKGC,IALH,CAKS,EALT,CAF+B,EAQ/BA,IAR+B,CAQzB,GARyB,CAAjC,C,CAUA;;AACA,MAAMC,uBAAuB,GAAG,CAC9B,GAAG,IAAIC,GAAJ,CACDnC,eAAe,CAACoC,MAAhB,CAAuB,CAACC,GAAD,EAAMC,GAAN,KAAc;AACnC,MAAI,CAACA,GAAG,CAACC,QAAJ,CAAc,GAAd,CAAL,EAAwB;AACtB,WAAOF,GAAG,CAACG,MAAJ,CAAWF,GAAG,CAACG,MAAf,CAAP;AACD,GAHkC,CAKnC;;;AACA,SAAOJ,GAAG,CAACG,MAAJ,CAAW,CAACF,GAAG,CAACG,MAAL,EAAaH,GAAG,CAACG,MAAJ,GAAa,CAA1B,EAA6BH,GAAG,CAACG,MAAJ,GAAa,CAA1C,CAAX,CAAP;AACD,CAPD,EAOG,EAPH,CADC,CAD2B,CAAhC,C,CAaA;AACA;;AACA,MAAMC,sBAAsB,GAAG,IAAIC,MAAJ,CAAY,KAAIf,wBAAyB,IAAzC,CAA/B;AAEA,MAAMgB,uBAAuB,GAAG,QAAhC,C,CACA;;AACA,MAAMC,qBAAqB,GAAG,SAA9B;AAEA;;;;;;;;;;;;;;AAaA,SAASC,cAAT,CAAwBnC,KAAxB,EAA+B;AAC7B;AACA,MACE,CAACA,KAAD,IACCA,KAAK,CAAC8B,MAAN,IAAgB,CAACP,uBAAuB,CAACa,QAAxB,CAAiCpC,KAAK,CAAC8B,MAAvC,CADlB,IAEA,CAACG,uBAAuB,CAACI,IAAxB,CAA6BrC,KAA7B,CAFD,IAGA,CAACkC,qBAAqB,CAACG,IAAtB,CAA2BrC,KAA3B,CAJH,EAKE;AACA,WAAO,KAAP;AACD,GAT4B,CAW7B;AACA;;;AACA,MAAI,OAAOA,KAAP,KAAkB,QAAlB,IAA6B+B,sBAAsB,CAACM,IAAvB,CAA4BrC,KAA5B,CAAjC,EAAqE;AACnE,WAAO,IAAP;AACD;;AAED,SAAOsC,MAAM,CAACtC,KAAD,CAAb;AACD;AAED;;;;;;AAIA,SAASsC,MAAT,CAAgBtC,KAAhB,EAAuB;AACrB,QAAMuC,UAAU,GAAGvD,MAAM,CAACwD,GAAP,CAAWxC,KAAX,EAAkBX,eAAlB,EAAmC,IAAnC,CAAnB;AACA,SAAO,OAAOW,KAAP,KAAkB,QAAlB,IAA6BuC,UAAU,CAACE,OAAX,EAApC;AACD;;AAED,MAAMC,UAAU,GAAG,CAAC;AAClBC,EAAAA,IADkB;AAElBC,EAAAA,OAFkB;AAGlBC,EAAAA,UAHkB;AAIlBC,EAAAA,YAJkB;AAKlBC,EAAAA,MAAM,GAAI;AALQ,CAAD,KAMb;AACJ,QAAMC,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeR,IAAf,CAAX,CAAvB;;AACA,MAAIG,YAAJ,EAAkB;AAChB,WAAO9D,MAAM,CACVwD,GADI,CACAQ,cADA,EACgB3D,eADhB,EACiC,IADjC,EAEJ0D,MAFI,CAEGA,MAFH,EAGJ5B,MAHI,CAGG2B,YAHH,CAAP;AAID,GALD,MAKO,IAAIF,OAAJ,EAAa;AAClB,WAAO5D,MAAM,CACVwD,GADI,CACAQ,cADA,EACgB3D,eADhB,EACiC,IADjC,EAEJ0D,MAFI,CAEGA,MAFH,EAGJH,OAHI,EAAP;AAID,GALM,MAKA,IAAIC,UAAJ,EAAgB;AACrB,WAAO7D,MAAM,GAAGoE,IAAT,CACLpE,MAAM,CAACwD,GAAP,CAAWQ,cAAX,EAA2B3D,eAA3B,EAA4C,IAA5C,EAAkD0D,MAAlD,CAAyDA,MAAzD,CADK,EAELF,UAFK,CAAP;AAID;;AACD,SAAOG,cAAP;AACD,CAzBD;;AA2BA,MAAMK,eAAe,GAAG,CAACC,OAAO,GAAG,EAAX,EAAeC,WAAf,KAA+B;AACrD,QAAM;AAAER,IAAAA,MAAF;AAAUD,IAAAA,YAAV;AAAwBF,IAAAA,OAAxB;AAAiCC,IAAAA;AAAjC,MAAgDS,OAAtD;AACA,SAAO;AACLE,IAAAA,IAAI,EAAE,EACJ,GAAGD,WAAW,CAACC,IADX;AAEJV,MAAAA,YAAY,EAAE;AACZW,QAAAA,IAAI,EAAG,QADK;AAEZjE,QAAAA,WAAW,EAAEJ,OAAQ;;;;gDAFT;AAOZsE,QAAAA,YAAY,EAAEZ;AAPF,OAFV;AAWJF,MAAAA,OAAO,EAAE;AACPa,QAAAA,IAAI,EAAG,SADA;AAEPjE,QAAAA,WAAW,EAAEJ,OAAQ;wEAFd;AAIPsE,QAAAA,YAAY,EAAEd;AAJP,OAXL;AAiBJC,MAAAA,UAAU,EAAE;AACVY,QAAAA,IAAI,EAAG,QADG;AAEVjE,QAAAA,WAAW,EAAEJ,OAAQ;;;;uBAFX;AAOVsE,QAAAA,YAAY,EAAEb;AAPJ,OAjBR;AA0BJE,MAAAA,MAAM,EAAE;AACNU,QAAAA,IAAI,EAAG,QADD;AAENjE,QAAAA,WAAW,EAAEJ,OAAQ;qEAFf;AAINsE,QAAAA,YAAY,EAAEX;AAJR;AA1BJ,KADD;;AAkCL,UAAMY,OAAN,CAAcC,MAAd,EAAsBJ,IAAtB,EAA4BK,OAA5B,EAAqCC,IAArC,EAA2C;AACzC,YAAMC,QAAQ,GAAGR,WAAW,CAACI,OAAZ,IAAuBE,OAAO,CAACG,oBAAhD;AACA,YAAMrB,IAAI,GAAG,MAAMoB,QAAQ,CAACH,MAAD,EAASJ,IAAT,EAAeK,OAAf,EAAwB,EACjD,GAAGC,IAD8C;AAEjDG,QAAAA,IAAI,EAAEX,OAAO,CAACW,IAAR,IAAgBH,IAAI,CAACG,IAFsB;AAGjDC,QAAAA,QAAQ,EAAEZ,OAAO,CAACW,IAAR,GAAeX,OAAO,CAACY,QAAvB,GAAkCJ,IAAI,CAACI;AAHA,OAAxB,CAA3B;AAKA,UAAIvB,IAAI,IAAI,IAAZ,EAAkB,OAAO,IAAP;AAElB,aAAOwB,KAAK,CAACC,OAAN,CAAczB,IAAd,IACHA,IAAI,CAACzB,GAAL,CAASmD,CAAC,IAAI3B,UAAU,CAAC;AAAEC,QAAAA,IAAI,EAAE0B,CAAR;AAAW,WAAGb;AAAd,OAAD,CAAxB,CADG,GAEHd,UAAU,CAAC;AAAEC,QAAAA,IAAF;AAAQ,WAAGa;AAAX,OAAD,CAFd;AAGD;;AA9CI,GAAP;AAgDD,CAlDD;;AAoDAc,MAAM,CAACC,OAAP,GAAiB;AAAEjF,EAAAA,WAAF;AAAe+D,EAAAA,eAAf;AAAgCf,EAAAA,MAAhC;AAAwCH,EAAAA;AAAxC,CAAjB","sourcesContent":["const moment = require(`moment`)\nconst { GraphQLScalarType, Kind } = require(`graphql`)\nconst { oneLine } = require(`common-tags`)\n\nconst ISO_8601_FORMAT = [\n  `YYYY`,\n  `YYYY-MM`,\n  `YYYY-MM-DD`,\n  `YYYYMMDD`,\n\n  // Local Time\n  `YYYY-MM-DDTHH`,\n  `YYYY-MM-DDTHH:mm`,\n  `YYYY-MM-DDTHHmm`,\n  `YYYY-MM-DDTHH:mm:ss`,\n  `YYYY-MM-DDTHHmmss`,\n  `YYYY-MM-DDTHH:mm:ss.SSS`,\n  `YYYY-MM-DDTHHmmss.SSS`,\n  `YYYY-MM-DDTHH:mm:ss.SSSSSS`,\n  `YYYY-MM-DDTHHmmss.SSSSSS`,\n  // `YYYY-MM-DDTHH:mm:ss.SSSSSSSSS`,\n  // `YYYY-MM-DDTHHmmss.SSSSSSSSS`,\n\n  // Local Time (Omit T)\n  `YYYY-MM-DD HH`,\n  `YYYY-MM-DD HH:mm`,\n  `YYYY-MM-DD HHmm`,\n  `YYYY-MM-DD HH:mm:ss`,\n  `YYYY-MM-DD HHmmss`,\n  `YYYY-MM-DD HH:mm:ss.SSS`,\n  `YYYY-MM-DD HHmmss.SSS`,\n  `YYYY-MM-DD HH:mm:ss.SSSSSS`,\n  `YYYY-MM-DD HHmmss.SSSSSS`,\n  // `YYYY-MM-DD HH:mm:ss.SSSSSSSSS`,\n  // `YYYY-MM-DD HHmmss.SSSSSSSSS`,\n\n  // Coordinated Universal Time (UTC)\n  `YYYY-MM-DDTHHZ`,\n  `YYYY-MM-DDTHH:mmZ`,\n  `YYYY-MM-DDTHHmmZ`,\n  `YYYY-MM-DDTHH:mm:ssZ`,\n  `YYYY-MM-DDTHHmmssZ`,\n  `YYYY-MM-DDTHH:mm:ss.SSSZ`,\n  `YYYY-MM-DDTHHmmss.SSSZ`,\n  `YYYY-MM-DDTHH:mm:ss.SSSSSSZ`,\n  `YYYY-MM-DDTHHmmss.SSSSSSZ`,\n  // `YYYY-MM-DDTHH:mm:ss.SSSSSSSSSZ`,\n  // `YYYY-MM-DDTHHmmss.SSSSSSSSSZ`,\n\n  // Coordinated Universal Time (UTC) (Omit T)\n  `YYYY-MM-DD HHZ`,\n  `YYYY-MM-DD HH:mmZ`,\n  `YYYY-MM-DD HHmmZ`,\n  `YYYY-MM-DD HH:mm:ssZ`,\n  `YYYY-MM-DD HHmmssZ`,\n  `YYYY-MM-DD HH:mm:ss.SSSZ`,\n  `YYYY-MM-DD HHmmss.SSSZ`,\n  `YYYY-MM-DD HH:mm:ss.SSSSSSZ`,\n  `YYYY-MM-DD HHmmss.SSSSSSZ`,\n  // `YYYY-MM-DD HH:mm:ss.SSSSSSSSSZ`,\n  // `YYYY-MM-DD HHmmss.SSSSSSSSSZ`,\n\n  // Coordinated Universal Time (UTC) (Omit T, Extra Space before Z)\n  `YYYY-MM-DD HH Z`,\n  `YYYY-MM-DD HH:mm Z`,\n  `YYYY-MM-DD HHmm Z`,\n  `YYYY-MM-DD HH:mm:ss Z`,\n  `YYYY-MM-DD HHmmss Z`,\n  `YYYY-MM-DD HH:mm:ss.SSS Z`,\n  `YYYY-MM-DD HHmmss.SSS Z`,\n  `YYYY-MM-DD HH:mm:ss.SSSSSS Z`,\n  `YYYY-MM-DD HHmmss.SSSSSS Z`,\n\n  `YYYY-[W]WW`,\n  `YYYY[W]WW`,\n  `YYYY-[W]WW-E`,\n  `YYYY[W]WWE`,\n  `YYYY-DDDD`,\n  `YYYYDDDD`,\n]\n\nconst GraphQLDate = new GraphQLScalarType({\n  name: `Date`,\n  description: oneLine`\n    A date string, such as 2007-12-03, compliant with the ISO 8601 standard\n    for representation of dates and times using the Gregorian calendar.`,\n  serialize: String,\n  parseValue: String,\n  parseLiteral(ast) {\n    return ast.kind === Kind.STRING ? ast.value : undefined\n  },\n})\n\nconst momentFormattingTokens = /(\\[[^[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g\nconst momentFormattingRegexes = {\n  YYYY: `\\\\d{4}`,\n  MM: `\\\\d{2}`,\n  DD: `\\\\d{2}`,\n  DDDD: `\\\\d{4}`,\n  HH: `\\\\d{2}`,\n  mm: `\\\\d{2}`,\n  ss: `\\\\d{2}`,\n  SSS: `\\\\d{3}`,\n  SSSSSS: `\\\\d{6}`,\n  E: `\\\\d`,\n  W: `\\\\d`,\n  WW: `\\\\d{2}`,\n  \"[W]\": `W`,\n  \".\": `\\\\.`,\n  Z: `(Z|[+-]\\\\d\\\\d(?::?\\\\d\\\\d)?)`,\n}\nconst ISO_8601_FORMAT_AS_REGEX = ISO_8601_FORMAT.map(format =>\n  // convert ISO string to a map of momentTokens ([YYYY, MM, DD])\n  [...format.match(momentFormattingTokens)]\n    .map(token =>\n      // see if the token (YYYY or ss) is found, else we just return the value\n      momentFormattingRegexes[token] ? momentFormattingRegexes[token] : token\n    )\n    .join(``)\n).join(`|`)\n\n// calculate all lengths of the formats, if a string is longer or smaller it can't be valid\nconst ISO_8601_FORMAT_LENGTHS = [\n  ...new Set(\n    ISO_8601_FORMAT.reduce((acc, val) => {\n      if (!val.endsWith(`Z`)) {\n        return acc.concat(val.length)\n      }\n\n      // we add count of +01 & +01:00\n      return acc.concat([val.length, val.length + 3, val.length + 5])\n    }, [])\n  ),\n]\n\n// lets imagine these formats: YYYY-MM-DDTHH & YYYY-MM-DD HHmmss.SSSSSS Z\n// this regex looks like (/^(\\d{4}-\\d{2}-\\d{2}T\\d{2}|\\d{4}-\\d{2}-\\d{2} \\d{2}\\d{2}\\d{2}.\\d{6} Z)$)\nconst quickDateValidateRegex = new RegExp(`^(${ISO_8601_FORMAT_AS_REGEX})$`)\n\nconst looksLikeDateStartRegex = /^\\d{4}/\n// this regex makes sure the last characters are a number or the letter Z\nconst looksLikeDateEndRegex = /(\\d|Z)$/\n\n/**\n * looksLikeADate isn't a 100% valid check if it is a real date but at least it's something that looks like a date.\n * It won't catch values like 2010-02-30\n * 1) is it a number?\n * 2) does the length of the value comply with any of our formats\n * 3) does the str starts with 4 digites (YYYY)\n * 4) does the str ends with something that looks like a date\n * 5) Small regex to see if it matches any of the formats\n * 6) check momentjs\n *\n * @param {*} value\n * @return {boolean}\n */\nfunction looksLikeADate(value) {\n  // quick check if value does not look like a date\n  if (\n    !value ||\n    (value.length && !ISO_8601_FORMAT_LENGTHS.includes(value.length)) ||\n    !looksLikeDateStartRegex.test(value) ||\n    !looksLikeDateEndRegex.test(value)\n  ) {\n    return false\n  }\n\n  // If it looks like a date we parse the date with a regex to see if we can handle it.\n  // momentjs just does regex validation itself if you don't do any operations on it.\n  if (typeof value === `string` && quickDateValidateRegex.test(value)) {\n    return true\n  }\n\n  return isDate(value)\n}\n\n/**\n * @param {*} value\n * @return {boolean}\n */\nfunction isDate(value) {\n  const momentDate = moment.utc(value, ISO_8601_FORMAT, true)\n  return typeof value !== `number` && momentDate.isValid()\n}\n\nconst formatDate = ({\n  date,\n  fromNow,\n  difference,\n  formatString,\n  locale = `en`,\n}) => {\n  const normalizedDate = JSON.parse(JSON.stringify(date))\n  if (formatString) {\n    return moment\n      .utc(normalizedDate, ISO_8601_FORMAT, true)\n      .locale(locale)\n      .format(formatString)\n  } else if (fromNow) {\n    return moment\n      .utc(normalizedDate, ISO_8601_FORMAT, true)\n      .locale(locale)\n      .fromNow()\n  } else if (difference) {\n    return moment().diff(\n      moment.utc(normalizedDate, ISO_8601_FORMAT, true).locale(locale),\n      difference\n    )\n  }\n  return normalizedDate\n}\n\nconst getDateResolver = (options = {}, fieldConfig) => {\n  const { locale, formatString, fromNow, difference } = options\n  return {\n    args: {\n      ...fieldConfig.args,\n      formatString: {\n        type: `String`,\n        description: oneLine`\n        Format the date using Moment.js' date tokens, e.g.\n        \\`date(formatString: \"YYYY MMMM DD\")\\`.\n        See https://momentjs.com/docs/#/displaying/format/\n        for documentation for different tokens.`,\n        defaultValue: formatString,\n      },\n      fromNow: {\n        type: `Boolean`,\n        description: oneLine`\n        Returns a string generated with Moment.js' \\`fromNow\\` function`,\n        defaultValue: fromNow,\n      },\n      difference: {\n        type: `String`,\n        description: oneLine`\n        Returns the difference between this date and the current time.\n        Defaults to \"milliseconds\" but you can also pass in as the\n        measurement \"years\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\",\n        and \"seconds\".`,\n        defaultValue: difference,\n      },\n      locale: {\n        type: `String`,\n        description: oneLine`\n        Configures the locale Moment.js will use to format the date.`,\n        defaultValue: locale,\n      },\n    },\n    async resolve(source, args, context, info) {\n      const resolver = fieldConfig.resolve || context.defaultFieldResolver\n      const date = await resolver(source, args, context, {\n        ...info,\n        from: options.from || info.from,\n        fromNode: options.from ? options.fromNode : info.fromNode,\n      })\n      if (date == null) return null\n\n      return Array.isArray(date)\n        ? date.map(d => formatDate({ date: d, ...args }))\n        : formatDate({ date, ...args })\n    },\n  }\n}\n\nmodule.exports = { GraphQLDate, getDateResolver, isDate, looksLikeADate }\n"],"file":"date.js"}