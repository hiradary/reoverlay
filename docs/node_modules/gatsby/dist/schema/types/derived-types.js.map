{"version":3,"sources":["../../../src/schema/types/derived-types.js"],"names":["ObjectTypeComposer","InterfaceTypeComposer","require","clearDerivedTypes","schemaComposer","typeComposer","derivedTypes","getDerivedTypes","typeName","values","derivedTypeComposer","getAnyTC","delete","removeInputTypeComposer","setExtension","Set","addDerivedType","derivedTypeName","add","getExtension","module","exports"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,MAAM;AAAEA,EAAAA,kBAAF;AAAsBC,EAAAA;AAAtB,IAAgDC,OAAO,CAAE,iBAAF,CAA7D;;AAEA,MAAMC,iBAAiB,GAAG,CAAC;AAAEC,EAAAA,cAAF;AAAkBC,EAAAA;AAAlB,CAAD,KAAsC;AAC9D,QAAMC,YAAY,GAAGC,eAAe,CAAC;AAAEF,IAAAA;AAAF,GAAD,CAApC;;AAEA,OAAK,MAAMG,QAAX,IAAuBF,YAAY,CAACG,MAAb,EAAvB,EAA8C;AAC5C,UAAMC,mBAAmB,GAAGN,cAAc,CAACO,QAAf,CAAwBH,QAAxB,CAA5B;AACAL,IAAAA,iBAAiB,CAAC;AAAEC,MAAAA,cAAF;AAAkBC,MAAAA,YAAY,EAAEK;AAAhC,KAAD,CAAjB;AACAN,IAAAA,cAAc,CAACQ,MAAf,CAAsBJ,QAAtB;AACD;;AAED,MACEH,YAAY,YAAYL,kBAAxB,IACAK,YAAY,YAAYJ,qBAF1B,EAGE;AACAI,IAAAA,YAAY,CAACQ,uBAAb;AACD;;AAEDR,EAAAA,YAAY,CAACS,YAAb,CAA2B,cAA3B,EAA0C,IAAIC,GAAJ,EAA1C;AACD,CAjBD;;AAmBA,MAAMC,cAAc,GAAG,CAAC;AAAEX,EAAAA,YAAF;AAAgBY,EAAAA;AAAhB,CAAD,KAAuC;AAC5D,QAAMX,YAAY,GAAGC,eAAe,CAAC;AAAEF,IAAAA;AAAF,GAAD,CAApC;AACAA,EAAAA,YAAY,CAACS,YAAb,CAA2B,cAA3B,EAA0CR,YAAY,CAACY,GAAb,CAAiBD,eAAjB,CAA1C;AACD,CAHD;;AAKA,MAAMV,eAAe,GAAG,CAAC;AAAEF,EAAAA;AAAF,CAAD,KACtBA,YAAY,CAACc,YAAb,CAA2B,cAA3B,KAA6C,IAAIJ,GAAJ,EAD/C;;AAGAK,MAAM,CAACC,OAAP,GAAiB;AACflB,EAAAA,iBADe;AAEfa,EAAAA;AAFe,CAAjB","sourcesContent":["/**\n * Derived types are types that make sense only when their base type exists\n *\n * Take this node for example:\n * {\n *   internal: { type: 'Foo' },\n *   fields: {\n *     bar: \"string\",\n *   }\n * }\n *\n * It will produce following types:\n * Foo\n * FooFields\n *\n * FooInputFilter\n * FooSortInput\n *\n * FooFieldsInputFilter\n * FooFieldsSortFilter\n * etc\n *\n * Derived types:\n *   Foo: FooFields, FooInputFilter, FooSortInput\n *   FooFields: FooFieldsInputFilter, FooFieldsSortFilter\n *\n * Caveats:\n *   Only types created via inference are marked as derived. So if in the example above\n *   user explicitly defines `FooFields` type (via `createTypes` call) it won't be considered\n *   a derived type\n */\nconst { ObjectTypeComposer, InterfaceTypeComposer } = require(`graphql-compose`)\n\nconst clearDerivedTypes = ({ schemaComposer, typeComposer }) => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n\n  for (const typeName of derivedTypes.values()) {\n    const derivedTypeComposer = schemaComposer.getAnyTC(typeName)\n    clearDerivedTypes({ schemaComposer, typeComposer: derivedTypeComposer })\n    schemaComposer.delete(typeName)\n  }\n\n  if (\n    typeComposer instanceof ObjectTypeComposer ||\n    typeComposer instanceof InterfaceTypeComposer\n  ) {\n    typeComposer.removeInputTypeComposer()\n  }\n\n  typeComposer.setExtension(`derivedTypes`, new Set())\n}\n\nconst addDerivedType = ({ typeComposer, derivedTypeName }) => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n  typeComposer.setExtension(`derivedTypes`, derivedTypes.add(derivedTypeName))\n}\n\nconst getDerivedTypes = ({ typeComposer }) =>\n  typeComposer.getExtension(`derivedTypes`) || new Set()\n\nmodule.exports = {\n  clearDerivedTypes,\n  addDerivedType,\n}\n"],"file":"derived-types.js"}