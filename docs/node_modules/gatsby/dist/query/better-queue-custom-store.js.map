{"version":3,"sources":["../../src/query/better-queue-custom-store.js"],"names":["MemoryStoreWithPriorityBuckets","uuid","queueMap","Map","tasks","taskIdToPriority","running","priorityKeys","updatePriorityKeys","Array","from","keys","sort","a","b","addTaskWithPriority","taskId","priority","needToUpdatePriorityKeys","priorityTasks","get","set","push","connect","cb","size","getTask","deleteTask","delete","splice","indexOf","putTask","task","oldTask","oldPriority","oldPriorityTasks","length","takeFirstN","n","lockId","remainingTasks","haveSomeTasks","tasksToRun","taskWithSamePriority","grabbedTaskIds","forEach","takeLastN","reverse","deleteCount","Math","min","getRunningTasks","getLock","releaseLock","module","exports"],"mappings":"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","sourcesContent":["function MemoryStoreWithPriorityBuckets() {\n  let uuid = 0\n\n  /**\n   * Task ids grouped by priority\n   */\n  const queueMap = new Map()\n\n  /**\n   * Task id to task lookup\n   */\n  const tasks = new Map()\n\n  /**\n   * Task id to priority lookup\n   */\n  const taskIdToPriority = new Map()\n\n  /**\n   * Lock to running tasks object\n   */\n  const running = {}\n\n  let priorityKeys = []\n  const updatePriorityKeys = () => {\n    priorityKeys = Array.from(queueMap.keys()).sort((a, b) => b - a)\n  }\n\n  const addTaskWithPriority = (taskId, priority) => {\n    let needToUpdatePriorityKeys = false\n    let priorityTasks = queueMap.get(priority)\n    if (!priorityTasks) {\n      priorityTasks = []\n      queueMap.set(priority, priorityTasks)\n      needToUpdatePriorityKeys = true\n    }\n\n    taskIdToPriority.set(taskId, priority)\n    priorityTasks.push(taskId)\n    return needToUpdatePriorityKeys\n  }\n\n  return {\n    connect: function (cb) {\n      cb(null, tasks.size)\n    },\n    getTask: function (taskId, cb) {\n      cb(null, tasks.get(taskId))\n    },\n    deleteTask: function (taskId, cb) {\n      if (tasks.get(taskId)) {\n        tasks.delete(taskId)\n        const priority = taskIdToPriority.get(taskId)\n        const priorityTasks = queueMap.get(priority)\n        priorityTasks.splice(priorityTasks.indexOf(taskId), 1)\n        taskIdToPriority.delete(taskId)\n      }\n      cb()\n    },\n    putTask: function (taskId, task, priority = 0, cb) {\n      const oldTask = tasks.get(taskId)\n      tasks.set(taskId, task)\n      let needToUpdatePriorityKeys = false\n      if (oldTask) {\n        const oldPriority = taskIdToPriority.get(taskId)\n\n        if (oldPriority !== priority) {\n          const oldPriorityTasks = queueMap.get(oldPriority)\n          oldPriorityTasks.splice(oldPriorityTasks.indexOf(taskId), 1)\n\n          if (\n            addTaskWithPriority(taskId, priority) ||\n            oldPriority.length === 0\n          ) {\n            needToUpdatePriorityKeys = true\n          }\n        }\n      } else {\n        needToUpdatePriorityKeys = addTaskWithPriority(taskId, priority)\n      }\n\n      if (needToUpdatePriorityKeys) {\n        updatePriorityKeys()\n      }\n      cb()\n    },\n    takeFirstN: function (n, cb) {\n      const lockId = uuid++\n      let remainingTasks = n\n      let needToUpdatePriorityKeys = false\n      let haveSomeTasks = false\n      const tasksToRun = {}\n\n      for (const priority of priorityKeys) {\n        const taskWithSamePriority = queueMap.get(priority)\n        const grabbedTaskIds = taskWithSamePriority.splice(0, remainingTasks)\n        grabbedTaskIds.forEach(taskId => {\n          // add task to task that will run\n          // and remove it from waiting list\n          tasksToRun[taskId] = tasks.get(taskId)\n          tasks.delete(taskId)\n          taskIdToPriority.delete(taskId)\n          haveSomeTasks = true\n        })\n\n        remainingTasks -= grabbedTaskIds.length\n        if (taskWithSamePriority.length === 0) {\n          queueMap.delete(priority)\n          needToUpdatePriorityKeys = true\n        }\n        if (remainingTasks <= 0) {\n          break\n        }\n      }\n\n      if (needToUpdatePriorityKeys) {\n        updatePriorityKeys()\n      }\n\n      if (haveSomeTasks) {\n        running[lockId] = tasksToRun\n      }\n\n      cb(null, lockId)\n    },\n    takeLastN: function (n, cb) {\n      // This is not really used by Gatsby, but will be implemented for\n      // completion in easiest possible way (so not very performant).\n      // Mostly done so generic test suite used by other stores passes.\n      // This is mostly C&P from takeFirstN, with array reversal and different\n      // splice args\n      const lockId = uuid++\n      let remainingTasks = n\n      let needToUpdatePriorityKeys = false\n      let haveSomeTasks = false\n      const tasksToRun = {}\n\n      for (const priority of priorityKeys.reverse()) {\n        const taskWithSamePriority = queueMap.get(priority)\n        const deleteCount = Math.min(\n          remainingTasks,\n          taskWithSamePriority.length\n        )\n        const grabbedTaskIds = taskWithSamePriority.splice(\n          taskWithSamePriority.length - deleteCount,\n          deleteCount\n        )\n        grabbedTaskIds.forEach(taskId => {\n          // add task to task that will run\n          // and remove it from waiting list\n          tasksToRun[taskId] = tasks.get(taskId)\n          tasks.delete(taskId)\n          taskIdToPriority.delete(taskId)\n          haveSomeTasks = true\n        })\n\n        remainingTasks -= grabbedTaskIds.length\n        if (taskWithSamePriority.length === 0) {\n          queueMap.delete(priority)\n          needToUpdatePriorityKeys = true\n        }\n        if (remainingTasks <= 0) {\n          break\n        }\n      }\n\n      if (needToUpdatePriorityKeys) {\n        updatePriorityKeys()\n      }\n\n      if (haveSomeTasks) {\n        running[lockId] = tasksToRun\n      }\n\n      cb(null, lockId)\n    },\n    getRunningTasks: function (cb) {\n      cb(null, running)\n    },\n    getLock: function (lockId, cb) {\n      cb(null, running[lockId])\n    },\n    releaseLock: function (lockId, cb) {\n      delete running[lockId]\n      cb()\n    },\n  }\n}\n\nmodule.exports = MemoryStoreWithPriorityBuckets\n"],"file":"better-queue-custom-store.js"}