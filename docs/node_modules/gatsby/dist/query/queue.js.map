{"version":3,"sources":["../../src/query/queue.js"],"names":["Queue","require","store","FastMemoryStore","queryRunner","websocketManager","GraphQLRunner","createBaseOptions","concurrent","Number","process","env","GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY","createBuildQueue","graphqlRunner","runnerOptions","handler","job","activity","callback","span","then","result","catch","queue","createDevelopQueue","getRunner","queueOptions","priority","cb","id","activePaths","has","merge","oldTask","newTask","queryJob","isPage","emitStaticQueryData","error","processBatch","jobs","length","Promise","resolve","reject","taskFinishCallback","tick","on","taskFailedCallback","err","gc","drainCallback","off","forEach","push","module","exports"],"mappings":"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","sourcesContent":["const Queue = require(`better-queue`)\nconst { store } = require(`../redux`)\nconst FastMemoryStore = require(`../query/better-queue-custom-store`)\nconst { queryRunner } = require(`../query/query-runner`)\nconst { websocketManager } = require(`../utils/websocket-manager`)\nconst { GraphQLRunner } = require(`./graphql-runner`)\n\nconst createBaseOptions = () => {\n  return {\n    concurrent: Number(process.env.GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY) || 4,\n    // eslint-disable-next-line new-cap\n    store: FastMemoryStore(),\n  }\n}\n\nconst createBuildQueue = (graphqlRunner, runnerOptions = {}) => {\n  if (!graphqlRunner) {\n    graphqlRunner = new GraphQLRunner(store, runnerOptions)\n  }\n  const handler = ({ job, activity }, callback) =>\n    queryRunner(graphqlRunner, job, activity?.span)\n      .then(result => callback(null, result))\n      .catch(callback)\n  const queue = new Queue(handler, createBaseOptions())\n  return queue\n}\n\nconst createDevelopQueue = getRunner => {\n  const queueOptions = {\n    ...createBaseOptions(),\n    priority: ({ job }, cb) => {\n      if (job.id && websocketManager.activePaths.has(job.id)) {\n        cb(null, 10)\n      } else {\n        cb(null, 1)\n      }\n    },\n    merge: (oldTask, newTask, cb) => {\n      cb(null, newTask)\n    },\n  }\n\n  const handler = ({ job: queryJob, activity }, callback) => {\n    queryRunner(getRunner(), queryJob, activity?.span).then(\n      result => {\n        if (!queryJob.isPage) {\n          websocketManager.emitStaticQueryData({\n            result,\n            id: queryJob.id,\n          })\n        }\n\n        callback(null, result)\n      },\n      error => callback(error)\n    )\n  }\n\n  return new Queue(handler, queueOptions)\n}\n\n/**\n * Returns a promise that pushes jobs onto queue and resolves onces\n * they're all finished processing (or rejects if one or more jobs\n * fail)\n * Note: queue is reused in develop so make sure to thoroughly cleanup hooks\n */\nconst processBatch = async (queue, jobs, activity) => {\n  if (jobs.length === 0) {\n    return Promise.resolve()\n  }\n\n  return new Promise((resolve, reject) => {\n    let taskFinishCallback\n    if (activity.tick) {\n      taskFinishCallback = () => activity.tick()\n      queue.on(`task_finish`, taskFinishCallback)\n    }\n\n    const taskFailedCallback = (...err) => {\n      gc()\n      reject(err)\n    }\n\n    const drainCallback = () => {\n      gc()\n      resolve()\n    }\n\n    const gc = () => {\n      queue.off(`task_failed`, taskFailedCallback)\n      queue.off(`drain`, drainCallback)\n      if (taskFinishCallback) {\n        queue.off(`task_finish`, taskFinishCallback)\n      }\n      queue = null\n    }\n\n    queue\n      // Note: the first arg is the path, the second the error\n      .on(`task_failed`, taskFailedCallback)\n      // Note: `drain` fires when all tasks _finish_\n      //       `empty` fires when queue is empty (but tasks are still running)\n      .on(`drain`, drainCallback)\n\n    jobs.forEach(job =>\n      queue.push({\n        job,\n        activity,\n      })\n    )\n  })\n}\n\nmodule.exports = {\n  createBuildQueue,\n  createDevelopQueue,\n  processBatch,\n}\n"],"file":"queue.js"}