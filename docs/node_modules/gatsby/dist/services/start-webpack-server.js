"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.startWebpackServer = startWebpackServer;

var _betterOpn = _interopRequireDefault(require("better-opn"));

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _formatWebpackMessages = _interopRequireDefault(require("react-dev-utils/formatWebpackMessages"));

var _chalk = _interopRequireDefault(require("chalk"));

var _webpackErrorUtils = require("../utils/webpack-error-utils");

var _printDeprecationWarnings = require("../utils/print-deprecation-warnings");

var _printInstructions = require("../utils/print-instructions");

var _prepareUrls = require("../utils/prepare-urls");

var _startServer = require("../utils/start-server");

var _webpackStatus = require("../utils/webpack-status");

var _pageData = require("../utils/page-data");

async function startWebpackServer({
  program,
  app,
  workerPool
}) {
  if (!program || !app) {
    throw new Error(`Missing required params`);
  }

  let {
    compiler,
    webpackActivity,
    websocketManager
  } = await (0, _startServer.startServer)(program, app, workerPool);
  compiler.hooks.invalid.tap(`log compiling`, function () {
    (0, _webpackStatus.markWebpackStatusAsPending)();
  });
  compiler.hooks.watchRun.tapAsync(`log compiling`, function (_, done) {
    if (webpackActivity) {
      webpackActivity.end();
    }

    webpackActivity = _reporter.default.activityTimer(`Re-building development bundle`, {
      id: `webpack-develop`
    });
    webpackActivity.start();
    done();
  });
  let isFirstCompile = true;
  return new Promise(resolve => {
    compiler.hooks.done.tapAsync(`print gatsby instructions`, async function (stats, done) {
      // "done" event fires when Webpack has finished recompiling the bundle.
      // Whether or not you have warnings or errors, you will get this event.
      // We have switched off the default Webpack output in WebpackDevServer
      // options so we are going to "massage" the warnings and errors and present
      // them in a readable focused way.
      const messages = (0, _formatWebpackMessages.default)(stats.toJson({}, true));
      const urls = (0, _prepareUrls.prepareUrls)(program.https ? `https` : `http`, program.host, program.proxyPort);
      const isSuccessful = !messages.errors.length;

      if (isSuccessful && isFirstCompile) {
        (0, _printInstructions.printInstructions)(program.sitePackageJson.name || `(Unnamed package)`, urls);
        (0, _printDeprecationWarnings.printDeprecationWarnings)();

        if (program.open) {
          try {
            await (0, _betterOpn.default)(urls.localUrlForBrowser);
          } catch {
            console.log(`${_chalk.default.yellow(`warn`)} Browser not opened because no browser was found`);
          }
        }
      }

      isFirstCompile = false;

      if (webpackActivity) {
        (0, _webpackErrorUtils.reportWebpackWarnings)(stats);

        if (!isSuccessful) {
          const errors = (0, _webpackErrorUtils.structureWebpackErrors)(`develop`, stats.compilation.errors);
          webpackActivity.panicOnBuild(errors);
        }

        webpackActivity.end();
        webpackActivity = null;
      }

      (0, _pageData.enqueueFlush)();
      (0, _webpackStatus.markWebpackStatusAsDone)();
      done();
      resolve({
        compiler,
        websocketManager
      });
    });
  });
}
//# sourceMappingURL=start-webpack-server.js.map