"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _bootstrap = require("../bootstrap");

var _redux = require("../redux");

var _getStaticDir = require("../utils/get-static-dir");

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _chalk = _interopRequireDefault(require("chalk"));

var _gatsbyTelemetry = _interopRequireDefault(require("gatsby-telemetry"));

var _express = _interopRequireDefault(require("express"));

var _schemaHotReloader = require("../bootstrap/schema-hot-reloader");

var _pageHotReloader = _interopRequireDefault(require("../bootstrap/page-hot-reloader"));

var _tracer = require("../utils/tracer");

var _db = _interopRequireDefault(require("../db"));

var _detectPortInUseAndPrompt = require("../utils/detect-port-in-use-and-prompt");

var _signalExit = _interopRequireDefault(require("signal-exit"));

var _query = _interopRequireDefault(require("../query"));

var _queryWatcher = _interopRequireDefault(require("../query/query-watcher"));

var requiresWriter = _interopRequireWildcard(require("../bootstrap/requires-writer"));

var _waitUntilJobsComplete = require("../utils/wait-until-jobs-complete");

var _feedback = require("../utils/feedback");

var _webpackStatus = require("../utils/webpack-status");

var _services = require("../services");

var _actions = require("../redux/actions");

var _types = require("../redux/types");

// const isInteractive = process.stdout.isTTY
// Watch the static directory and copy files to public as they're added or
// changed. Wait 10 seconds so copying doesn't interfere with the regular
// bootstrap.
setTimeout(() => {
  (0, _getStaticDir.syncStaticDir)();
}, 10000); // Time for another story...
// When the parent process is killed by SIGKILL, Node doesm't kill spawned child processes
// Hence, we peiodically send a heart beat to the parent to check if it is still alive
// This will crash with Error [ERR_IPC_CHANNEL_CLOSED]: Channel closed
// and kill the orphaned child process as a result

if (process.send) {
  setInterval(() => {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    process.send({
      type: `HEARTBEAT`
    });
  }, 1000);
}

(0, _signalExit.default)(() => {
  _gatsbyTelemetry.default.trackCli(`DEVELOP_STOP`);
});
process.on(`message`, msg => {
  if (msg.type === `COMMAND` && msg.action.type === `EXIT`) {
    process.exit(msg.action.payload);
  }
});

module.exports = async program => {
  // We want to prompt the feedback request when users quit develop
  // assuming they pass the heuristic check to know they are a user
  // we want to request feedback from, and we're not annoying them.
  process.on(`SIGINT`, async () => {
    if (await (0, _feedback.userPassesFeedbackRequestHeuristic)()) {
      (0, _feedback.showFeedbackRequest)();
    }

    process.exit(0);
  });

  if (process.env.GATSBY_EXPERIMENTAL_PAGE_BUILD_ON_DATA_CHANGES) {
    _reporter.default.panic(`The flag ${_chalk.default.yellow(`GATSBY_EXPERIMENTAL_PAGE_BUILD_ON_DATA_CHANGES`)} is not available with ${_chalk.default.cyan(`gatsby develop`)}, please retry using ${_chalk.default.cyan(`gatsby build`)}`);
  }

  (0, _tracer.initTracer)(program.openTracingConfigFile);
  (0, _webpackStatus.markWebpackStatusAsPending)();

  _reporter.default.pendingActivity({
    id: `webpack-develop`
  });

  _gatsbyTelemetry.default.trackCli(`DEVELOP_START`);

  _gatsbyTelemetry.default.startBackgroundUpdate();

  const port = typeof program.port === `string` ? parseInt(program.port, 10) : program.port;

  try {
    program.port = await (0, _detectPortInUseAndPrompt.detectPortInUseAndPrompt)(port);
  } catch (e) {
    if (e.message === `USER_REJECTED`) {
      process.exit(0);
    }

    throw e;
  } // Start bootstrap process.


  const {
    gatsbyNodeGraphQLFunction,
    workerPool
  } = await (0, _bootstrap.bootstrap)({
    program
  }); // Start the createPages hot reloader.

  (0, _pageHotReloader.default)(gatsbyNodeGraphQLFunction); // Start the schema hot reloader.

  (0, _schemaHotReloader.bootstrapSchemaHotReloader)();
  const {
    queryIds
  } = await (0, _services.calculateDirtyQueries)({
    store: _redux.store
  });
  await (0, _services.runStaticQueries)({
    queryIds,
    store: _redux.store,
    program
  });
  await (0, _services.runPageQueries)({
    queryIds,
    store: _redux.store,
    program
  });
  await (0, _services.writeOutRequires)({
    store: _redux.store
  });

  _actions.boundActionCreators.setProgramStatus(_types.ProgramStatus.BOOTSTRAP_QUERY_RUNNING_FINISHED);

  await _db.default.saveState();
  await (0, _waitUntilJobsComplete.waitUntilAllJobsComplete)();
  requiresWriter.startListener();

  _db.default.startAutosave();

  _query.default.startListeningToDevelopQueue({
    graphqlTracing: program.graphqlTracing
  });

  _queryWatcher.default.startWatchDeletePage();

  const app = (0, _express.default)();
  await (0, _services.startWebpackServer)({
    program,
    app,
    workerPool
  });
};
//# sourceMappingURL=develop-process.js.map